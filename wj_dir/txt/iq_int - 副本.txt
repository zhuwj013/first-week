#! /bin/bash
########################################################################################################################################文件准备
########################################################################################################################################
########################################################################################################################################
iq_data="iq_data.lmu"
####################################################################检查文件是否存在（-f file：文件为一般文件）
if [[ ! -f  "$iq_data" ]]; then
echo "错误：找不到文件 $iq_data"
exit 1
fi
####################################################################检查文件是否可读（-r file：文件可读）
if [[ ! -r "$iq_data" ]]; then
echo "错误：文件 $iq_data 不可读"
exit 1
fi
####################################################################检查文件是否为空（-s file：文件不是空的）
if [[ ! -s "$iq_data" ]]; then
echo "错误：文件 $iq_data 为空"
exit 0
fi
########################################################################################################################################数据提取、存储
########################################################################################################################################
########################################################################################################################################
declare -A iq_x_data
declare -A iq_m_data
declare -A iq_count_data
####################################################################循环读取每一行数据
count_iq=0
while read -r line || [[ -n  "$line" ]]; do
if [[ "$line" =~ \(IQ([0-9]+)\)=(.*) ]]; then
iq="${BASH_REMATCH[1]}"
data="${BASH_REMATCH[2]}"
((count_iq++))
####################################################################分别存储x，m值的数组
x_values=()
m_values=()
count=0
while [[ "$data" =~ M[[:space:]]+([0-9]+)X[[:space:]]+([0-9]+)(.*) ]]; do
m="${BASH_REMATCH[1]}"
x="${BASH_REMATCH[2]}"
data="${BASH_REMATCH[3]}"
((count++))
x_values+=("$x")
m_values+=("$m")
done
#echo "${x_values[*]}"
#echo "${m_values[*]}"
####################################################################分别将x、m值数组转换为字符串存储
iq_count_data["$iq"]="$count"
iq_x_data["$iq"]="${x_values[*]}"
iq_m_data["$iq"]="${m_values[*]}"
fi
#echo "${iq_x_data[$iq]}"
#echo "${iq_m_data[$iq]}"
####################################################################输入数据
done < <(tr '\n' ' ' < iq_data.lmu | sed  's/ *(IQ/\n(IQ/g; s/^[[:space:]]*//; s/,TAP10,\?//g;  /^$/d')
########################################################################################################################################一维插值函数(定义函数，参数)
########################################################################################################################################
########################################################################################################################################
int_1d() {
local iq="$1"
local x_tg="$2"
##############################将x、m值字符串转换为数组
x_data=(${iq_x_data[$iq]})
m_data=(${iq_m_data[$iq]})
##############################循环查找区间(${#x_data[@]}：数组长度)，循环遍历每个相邻的数据点对
for ((i=0; i<${#x_data[@]}-1; i++)); do
##############################查找包含目标x值的区间（x_tg）
x1=${x_data[i]} #当前的x值
x2=${x_data[i+1]} #下一个x值
if [[ $x_tg -ge $x1 && $x_tg -le $x2 ]]; then
m1=${m_data[i]} #当前的m值
m2=${m_data[i+1]} #下一个m值
##############################线性插值计算(bc：Bash计算器，用于浮点计算)（-l：加载数学库，支持更精确的计算）（return：找到区间并计算后，立即返回结果）
echo "$m1 + ($x_tg - $x1) * ($m2 - $m1) / ($x2 - $x1)" | bc -l
return
 fi
done

##############################如果没有找到合适的区间，返回NaN
echo "NaN"
}
########################################################################################################################################二维插值函数
########################################################################################################################################
########################################################################################################################################
int_2d() {
local iq_tg="$1"
local x_tg="$2"
##############################获取所有的IQ值并排序(${!iq_x_data[@]}：获取关联数组的所有键（IQ值）)（sort -n：按数字排序）
iq_values=($(echo "${!iq_x_data[@]}" | tr ' ' '\n' | sort -n))
##############################找到相邻的IQ值
for ((i=0; i<${#iq_values[@]}-1; i++)); do
iq1=${iq_values[i]} #当前的iq值
iq2=${iq_values[i+1]} #下一个iq值
if [[ $iq_tg -ge $iq1 && $iq_tg -le $iq2 ]]; then
#一维插值(在iq1处对x插值；在iq2处对x插值)
m1=$(int_1d "$iq1" "$x_tg")
m2=$(int_1d "$iq2" "$x_tg")
# 二维插值计算
echo "$m1 + ($iq_tg - $iq1) * ($m2 - $m1) / ($iq2 - $iq1)" | bc -l
return
fi
done

echo "NaN"
}
########################################################################################################################################IQ_int实现
########################################################################################################################################
########################################################################################################################################
while true; do
echo "请输入IQ值："
read iq_input
echo "请输入x值："
read x_input
result=$(int_2d "$iq_input" "$x_input")
echo "插值结果 M = $result"
done












